package com.hexa.vulnfix.service;


import java.io.FileReader;
import java.io.FileWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.HashMap;
import java.util.Map;

import org.apache.maven.model.Dependency;
import org.apache.maven.model.Model;
import org.apache.maven.model.io.xpp3.MavenXpp3Reader;
import org.apache.maven.model.io.xpp3.MavenXpp3Writer;
import org.owasp.dependencycheck.Engine;
import org.owasp.dependencycheck.exception.ExceptionCollection;
import org.owasp.dependencycheck.utils.Settings;
import org.springframework.beans.factory.annotation.Value;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

public class PomVulnerabilityFixer {
	@Value("${dependency-check.nvd-api-key}")
	private String nvdApiKey;

    // üìç Base directory (D drive)
    private static final Path BASE_DIR = Paths.get("D:/vuln-fix");

    /**
     * MAIN ENTRY METHOD
     */
    public void updatePom(Path extractedProjectDir) throws Exception {

        Path originalPom = extractedProjectDir.resolve("pom.xml");
        if (!Files.exists(originalPom)) {
            System.out.println("‚ùå pom.xml not found");
            return;
        }

        // 1Ô∏è‚É£ Run OWASP Dependency-Check
        Path reportJson = runDependencyCheck(extractedProjectDir);

        Map<String, String> safeVersions = extractSafeVersions(reportJson);

        if (safeVersions.isEmpty()) {
            System.out.println("‚úÖ No vulnerable dependencies found");
            return;
        }

        // 3Ô∏è‚É£ Read original pom
        Model model;
        try (FileReader reader = new FileReader(originalPom.toFile())) {
            model = new MavenXpp3Reader().read(reader);
        }

        // 4Ô∏è‚É£ Update dependencies using OWASP data
        for (Dependency d : model.getDependencies()) {
            if (safeVersions.containsKey(d.getArtifactId())) {
                d.setVersion(safeVersions.get(d.getArtifactId()));
            }
        }

        // 5Ô∏è‚É£ Create output folders on D drive
        Path projectDirOnD =
                BASE_DIR.resolve("upload-" + System.currentTimeMillis());

        Path originalDir = projectDirOnD.resolve("original");
        Path updatedDir  = projectDirOnD.resolve("updated");

        Files.createDirectories(originalDir);
        Files.createDirectories(updatedDir);

        // 6Ô∏è‚É£ Copy original pom
        Files.copy(originalPom,
                originalDir.resolve("pom.xml"),
                StandardCopyOption.REPLACE_EXISTING);

        // 7Ô∏è‚É£ Write updated pom
        try (FileWriter writer =
                     new FileWriter(updatedDir.resolve("pom.xml").toFile())) {
            new MavenXpp3Writer().write(writer, model);
        }

        System.out.println("üìÑ Original POM : " + originalDir.toAbsolutePath());
        System.out.println("üõ° Updated  POM : " + updatedDir.toAbsolutePath());
    }

    /**
     * Runs OWASP Dependency-Check on pom.xml
     */
    private Path runDependencyCheck(Path projectDir) throws Exception {

        Path reportDir = projectDir.resolve("dc-report");
        Files.createDirectories(reportDir);

        Settings settings = new Settings();
        settings.setString("nvd.api.key", "5fc305df-dc71-4c58-b1b5-e8fde3296247");
        settings.setBoolean("analyzer.node.enabled", false);
        settings.setBoolean("analyzer.assembly.enabled", false);
        settings.setBoolean("analyzer.nodeAudit.enabled", false);
        settings.setBoolean("analyzer.nugetconf.enabled", false);

        Engine engine = new Engine(settings);

        engine.scan(projectDir.resolve("pom.xml").toFile());
        engine.analyzeDependencies();

        engine.writeReports(
                projectDir.getFileName().toString(), // application name
                reportDir.toFile(),                  // output directory
                "JSON",                               // report format
                new ExceptionCollection()             // required by API
        );


        engine.close();

        return reportDir.resolve("dependency-check-report.json");
    }

    /**
     * Reads Dependency-Check JSON and finds fixed versions
     */
    private Map<String, String> extractSafeVersions(Path reportJson) throws Exception {

        Map<String, String> safeVersions = new HashMap<>();

        ObjectMapper mapper = new ObjectMapper();
        JsonNode root = mapper.readTree(reportJson.toFile());

        for (JsonNode dep : root.path("dependencies")) {

            String artifactId = dep.path("artifactId").asText(null);
            if (artifactId == null) continue;

            for (JsonNode vuln : dep.path("vulnerabilities")) {

                JsonNode fixed = vuln.path("fixedVersions");
                if (fixed.isArray() && fixed.size() > 0) {
                    // choose lowest fixed version
                    safeVersions.put(artifactId, fixed.get(0).asText());
                    break;
                }
            }
        }
        return safeVersions;
    }
}
